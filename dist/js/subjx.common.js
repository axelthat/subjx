/*@license
* Drag/Rotate/Resize Library
* Released under the MIT license, 2018-2021
* Karen Sarksyan
* nichollascarter@gmail.com
*/
"use strict";const requestAnimFrame=window.requestAnimationFrame||window.mozRequestAnimationFrame||window.webkitRequestAnimationFrame||window.msRequestAnimationFrame||function(t){return setTimeout(t,1e3/60)},cancelAnimFrame=window.cancelAnimationFrame||window.mozCancelAnimationFrame||function(t){clearTimeout(t)},{forEach:forEach,slice:arrSlice,map:arrMap,reduce:arrReduce}=Array.prototype,{warn:warn}=console,isDef=t=>null!=t,isUndef=t=>null==t,isFunc=t=>"function"==typeof t,createMethod=t=>isFunc(t)?function(){t.call(this,...arguments)}:()=>{};class Helper{constructor(t){if("string"==typeof t){const e=document.querySelectorAll(t);this.length=e.length;for(let t=0;t<this.length;t++)this[t]=e[t]}else if("object"!=typeof t||1!==t.nodeType&&t!==document)if(t instanceof Helper){this.length=t.length;for(let e=0;e<this.length;e++)this[e]=t[e]}else{if(!isIterable(t))throw new Error("Passed parameter must be selector/element/elementArray");this.length=0;for(let e=0;e<this.length;e++)1===t.nodeType&&(this[e]=t[e],this.length++)}else this[0]=t,this.length=1}css(t){const e={setStyle(t){return((t,e)=>{let r=t.length;for(;r--;)for(const s in e)t[r].style[s]=e[s];return t.style})(this,t)},getStyle(){return(e=>{let r=e.length;for(;r--;)return e[r].currentStyle?e[r].currentStyle[t]:document.defaultView&&document.defaultView.getComputedStyle?document.defaultView.getComputedStyle(e[r],"")[t]:e[r].style[t]})(this)}};return"string"==typeof t?e.getStyle.apply(this,arrSlice.call(arguments,1)):"object"!=typeof t&&t?(warn(`Method ${t} does not exist`),!1):e.setStyle.apply(this,arguments)}on(){let t=this.length;for(;t--;)this[t].events||(this[t].events={},this[t].events[arguments[0]]=[]),"string"!=typeof arguments[1]?document.addEventListener?this[t].addEventListener(arguments[0],arguments[1],arguments[2]||{passive:!1}):document.attachEvent?this[t].attachEvent(`on${arguments[0]}`,arguments[1]):this[t][`on${arguments[0]}`]=arguments[1]:listenerDelegate(this[t],arguments[0],arguments[1],arguments[2],arguments[3],!0);return this}off(){let t=this.length;for(;t--;)this[t].events||(this[t].events={},this[t].events[arguments[0]]=[]),"string"!=typeof arguments[1]?document.removeEventListener?this[t].removeEventListener(arguments[0],arguments[1],arguments[2]):document.detachEvent?this[t].detachEvent(`on${arguments[0]}`,arguments[1]):this[t][`on${arguments[0]}`]=null:listenerDelegate(this[t],arguments[0],arguments[1],arguments[2],arguments[3],!1);return this}is(t){if(isUndef(t))return!1;const e=helper(t);let r=this.length;for(;r--;)if(this[r]===e[r])return!0;return!1}}function listenerDelegate(t,e,r,s,a,o){const n=function(t){let e=t.target;for(;e&&e!==this;)e.matches(r)&&s.call(e,t),e=e.parentNode};!0===o?document.addEventListener?t.addEventListener(e,n,a||{passive:!1}):document.attachEvent?t.attachEvent(`on${e}`,n):t[`on${e}`]=n:document.removeEventListener?t.removeEventListener(e,n,a||{passive:!1}):document.detachEvent?t.detachEvent(`on${e}`,n):t[`on${e}`]=null}function isIterable(t){return isDef(t)&&"object"==typeof t&&(Array.isArray(t)||isDef(window.Symbol)&&"function"==typeof t[window.Symbol.iterator]||isDef(t.forEach)||"number"==typeof t.length&&(0===t.length||t.length>0&&t.length-1 in t))}function helper(t){return new Helper(t)}const MIN_SIZE=2,THEME_COLOR="#00a8ff",LIB_CLASS_PREFIX="sjx-",E_MOUSEDOWN="mousedown",E_MOUSEUP="mouseup",E_MOUSEMOVE="mousemove",E_TOUCHSTART="touchstart",E_TOUCHEND="touchend",E_TOUCHMOVE="touchmove",E_DRAG_START="dragStart",E_DRAG="drag",E_DRAG_END="dragEnd",E_RESIZE_START="resizeStart",E_RESIZE="resize",E_RESIZE_END="resizeEnd",E_ROTATE_START="rotateStart",E_ROTATE="rotate",E_ROTATE_END="rotateEnd",E_SET_POINT_START="setPointStart",E_SET_POINT_END="setPointEnd",EMITTER_EVENTS=["dragStart","drag",,"dragEnd","resizeStart","resize","resizeEnd","rotateStart","rotate","rotateEnd","setPointStart","setPointEnd"],CSS_PREFIXES=["","-webkit-","-moz-","-ms-","-o-"],ON_GETSTATE="ongetstate",ON_APPLY="onapply",ON_MOVE="onmove",ON_RESIZE="onresize",ON_ROTATE="onrotate",NOTIFIER_EVENTS=[ON_GETSTATE,ON_APPLY,ON_MOVE,ON_RESIZE,ON_ROTATE],NOTIFIER_CONSTANTS={NOTIFIER_EVENTS:NOTIFIER_EVENTS,ON_GETSTATE:ON_GETSTATE,ON_APPLY:ON_APPLY,ON_MOVE:ON_MOVE,ON_RESIZE:ON_RESIZE,ON_ROTATE:ON_ROTATE},EVENT_EMITTER_CONSTANTS={EMITTER_EVENTS:EMITTER_EVENTS,E_DRAG_START:"dragStart",E_DRAG:"drag",E_DRAG_END:"dragEnd",E_RESIZE_START:"resizeStart",E_RESIZE:"resize",E_RESIZE_END:"resizeEnd",E_ROTATE_START:"rotateStart",E_ROTATE:"rotate",E_ROTATE_END:"rotateEnd",E_SET_POINT_START:"setPointStart",E_SET_POINT_END:"setPointEnd"},CLIENT_EVENTS_CONSTANTS={E_MOUSEDOWN:"mousedown",E_MOUSEUP:"mouseup",E_MOUSEMOVE:"mousemove",E_TOUCHSTART:"touchstart",E_TOUCHEND:"touchend",E_TOUCHMOVE:"touchmove"},TRANSFORM_HANDLES_KEYS={TOP_LEFT:"tl",TOP_CENTER:"tc",TOP_RIGHT:"tr",BOTTOM_LEFT:"bl",BOTTOM_RIGHT:"br",BOTTOM_CENTER:"bc",MIDDLE_LEFT:"ml",MIDDLE_RIGHT:"mr",CENTER:"center"},TRANSFORM_EDGES_KEYS={TOP_EDGE:"te",BOTTOM_EDGE:"be",LEFT_EDGE:"le",RIGHT_EDGE:"re"},TRANSFORM_HANDLES_CONSTANTS={TRANSFORM_HANDLES_KEYS:TRANSFORM_HANDLES_KEYS,TRANSFORM_EDGES_KEYS:TRANSFORM_EDGES_KEYS},{ON_GETSTATE:ON_GETSTATE$1,ON_APPLY:ON_APPLY$1,ON_MOVE:ON_MOVE$1,ON_RESIZE:ON_RESIZE$1,ON_ROTATE:ON_ROTATE$1}=NOTIFIER_CONSTANTS;class Observable{constructor(){this.observers={}}subscribe(t,e){const r=this.observers;return isUndef(r[t])&&Object.defineProperty(r,t,{value:[]}),r[t].push(e),this}unsubscribe(t,e){const r=this.observers;if(isDef(r[t])){const s=r[t].indexOf(e);r[t].splice(s,1)}return this}notify(t,e,r){isUndef(this.observers[t])||this.observers[t].forEach(s=>{if(e!==s)switch(t){case ON_MOVE$1:s.notifyMove(r);break;case ON_ROTATE$1:s.notifyRotate(r);break;case ON_RESIZE$1:s.notifyResize(r);break;case ON_APPLY$1:s.notifyApply(r);break;case ON_GETSTATE$1:s.notifyGetState(r)}})}}class Event{constructor(t){this.name=t,this.callbacks=[]}registerCallback(t){this.callbacks.push(t)}removeCallback(t){const e=this.callbacks(t);this.callbacks.splice(e,1)}}class EventDispatcher{constructor(){this.events={}}registerEvent(t){this.events[t]=new Event(t)}emit(t,e,r){this.events[e].callbacks.forEach(e=>{e.call(t,r)})}addEventListener(t,e){this.events[t].registerCallback(e)}removeEventListener(t,e){this.events[t].removeCallback(e)}}const{E_DRAG:E_DRAG$1}=EVENT_EMITTER_CONSTANTS,{E_MOUSEMOVE:E_MOUSEMOVE$1,E_MOUSEUP:E_MOUSEUP$1,E_TOUCHMOVE:E_TOUCHMOVE$1,E_TOUCHEND:E_TOUCHEND$1}=CLIENT_EVENTS_CONSTANTS;class SubjectModel{constructor(t){this.el=t,this.storage=null,this.proxyMethods=null,this.eventDispatcher=new EventDispatcher,this._onMouseDown=this._onMouseDown.bind(this),this._onTouchStart=this._onTouchStart.bind(this),this._onMouseMove=this._onMouseMove.bind(this),this._onTouchMove=this._onTouchMove.bind(this),this._onMouseUp=this._onMouseUp.bind(this),this._onTouchEnd=this._onTouchEnd.bind(this),this._animate=this._animate.bind(this)}enable(t){this._processOptions(t),this._init(this.el),this.proxyMethods.onInit.call(this,this.el)}disable(){throwNotImplementedError()}_init(){throwNotImplementedError()}_destroy(){throwNotImplementedError()}_processOptions(){throwNotImplementedError()}_start(){throwNotImplementedError()}_moving(){throwNotImplementedError()}_end(){throwNotImplementedError()}_animate(){throwNotImplementedError()}_drag({dx:t,dy:e,...r}){const s={dx:t,dy:e,transform:this._processMove(t,e),...r};this.proxyMethods.onMove.call(this,s),this._emitEvent(E_DRAG$1,s)}_draw(){this._animate()}_onMouseDown(t){this._start(t),helper(document).on(E_MOUSEMOVE$1,this._onMouseMove).on(E_MOUSEUP$1,this._onMouseUp)}_onTouchStart(t){this._start(t.touches[0]),helper(document).on(E_TOUCHMOVE$1,this._onTouchMove).on(E_TOUCHEND$1,this._onTouchEnd)}_onMouseMove(t){t.preventDefault&&t.preventDefault(),this._moving(t,this.el)}_onTouchMove(t){t.preventDefault&&t.preventDefault(),this._moving(t.touches[0],this.el)}_onMouseUp(t){helper(document).off(E_MOUSEMOVE$1,this._onMouseMove).off(E_MOUSEUP$1,this._onMouseUp),this._end(t,this.el)}_onTouchEnd(t){helper(document).off(E_TOUCHMOVE$1,this._onTouchMove).off(E_TOUCHEND$1,this._onTouchEnd),0===t.touches.length&&this._end(t.changedTouches[0],this.el)}_emitEvent(){this.eventDispatcher.emit(this,...arguments)}on(t,e){return this.eventDispatcher.addEventListener(t,e),this}off(t,e){return this.eventDispatcher.removeEventListener(t,e),this}}const throwNotImplementedError=()=>{throw Error("Method not implemented")},RAD=Math.PI/180,snapCandidate=(t,e)=>0===e?t:Math.round(t/e)*e,snapToGrid=(t,e)=>{if(0===e)return t;{const r=snapCandidate(t,e);if(r-t<e)return r}},floatToFixed=(t,e=6)=>Number(t.toFixed(e)),getMinMaxOf2DIndex=(t,e)=>{const r=t.map(t=>t[e]);return[Math.min(...r),Math.max(...r)]},getOffset=t=>t.getBoundingClientRect(),addClass=(t,e)=>{if(e){if(t.classList){if(!(e.indexOf(" ")>-1))return t.classList.add(e);e.split(/\s+/).forEach(e=>t.classList.add(e))}return t}},removeClass=(t,e)=>{if(e){if(t.classList){if(!(e.indexOf(" ")>-1))return t.classList.remove(e);e.split(/\s+/).forEach(e=>t.classList.remove(e))}return t}},objectsCollide=(t,e)=>{const{top:r,left:s}=getOffset(t),{top:a,left:o}=getOffset(e),n=helper(t),i=helper(e);return!(r<a||r+parseFloat(n.css("height"))>a+parseFloat(i.css("height"))||s<o||s+parseFloat(n.css("width"))>o+parseFloat(i.css("width")))},matrixToCSS=t=>{const e=`matrix3d(${t.join()})`;return{transform:e,webkitTranform:e,mozTransform:e,msTransform:e,otransform:e}},getStyle=(t,e)=>{const r=window.getComputedStyle(t);let s=null;for(const t of CSS_PREFIXES)if(s=r.getPropertyValue(`${t}${e}`)||s)break;return s},{NOTIFIER_EVENTS:NOTIFIER_EVENTS$1,ON_GETSTATE:ON_GETSTATE$2,ON_APPLY:ON_APPLY$2,ON_MOVE:ON_MOVE$2,ON_RESIZE:ON_RESIZE$2,ON_ROTATE:ON_ROTATE$2}=NOTIFIER_CONSTANTS,{EMITTER_EVENTS:EMITTER_EVENTS$1,E_DRAG_START:E_DRAG_START$1,E_DRAG:E_DRAG$2,E_DRAG_END:E_DRAG_END$1,E_RESIZE_START:E_RESIZE_START$1,E_RESIZE:E_RESIZE$1,E_RESIZE_END:E_RESIZE_END$1,E_ROTATE_START:E_ROTATE_START$1,E_ROTATE:E_ROTATE$1,E_ROTATE_END:E_ROTATE_END$1}=EVENT_EMITTER_CONSTANTS,{TRANSFORM_HANDLES_KEYS:TRANSFORM_HANDLES_KEYS$1,TRANSFORM_EDGES_KEYS:TRANSFORM_EDGES_KEYS$1}=TRANSFORM_HANDLES_CONSTANTS,{E_MOUSEDOWN:E_MOUSEDOWN$1,E_TOUCHSTART:E_TOUCHSTART$1,E_MOUSEMOVE:E_MOUSEMOVE$2,E_MOUSEUP:E_MOUSEUP$2,E_TOUCHMOVE:E_TOUCHMOVE$2,E_TOUCHEND:E_TOUCHEND$2}=CLIENT_EVENTS_CONSTANTS,{TOP_LEFT:TOP_LEFT,TOP_CENTER:TOP_CENTER,TOP_RIGHT:TOP_RIGHT,BOTTOM_LEFT:BOTTOM_LEFT,BOTTOM_RIGHT:BOTTOM_RIGHT,BOTTOM_CENTER:BOTTOM_CENTER,MIDDLE_LEFT:MIDDLE_LEFT,MIDDLE_RIGHT:MIDDLE_RIGHT}=TRANSFORM_HANDLES_KEYS$1,{TOP_EDGE:TOP_EDGE,BOTTOM_EDGE:BOTTOM_EDGE,LEFT_EDGE:LEFT_EDGE,RIGHT_EDGE:RIGHT_EDGE}=TRANSFORM_EDGES_KEYS$1;class Transformable extends SubjectModel{constructor(t,e,r){if(super(t),this.constructor===Transformable)throw new TypeError("Cannot construct Transformable instances directly");this.observable=r,EMITTER_EVENTS$1.forEach(t=>this.eventDispatcher.registerEvent(t)),this.enable(e)}_cursorPoint(){throw Error("'_cursorPoint()' method not implemented")}_rotate({radians:t,...e}){const r={transform:this._processRotate(t),delta:t,...e};this.proxyMethods.onRotate.call(this,r),this._emitEvent(E_ROTATE$1,r)}_resize({dx:t,dy:e,...r}){const s={...this._processResize(t,e),dx:t,dy:e,...r};this.proxyMethods.onResize.call(this,s),this._emitEvent(E_RESIZE$1,s)}_processOptions(t={}){const{el:e}=this;addClass(e,`${LIB_CLASS_PREFIX}drag`);const{each:r={move:!1,resize:!1,rotate:!1},snap:s={x:10,y:10,angle:10},axis:a="xy",cursorMove:o="auto",cursorResize:n="auto",cursorRotate:i="auto",rotationPoint:l=!1,restrict:c,draggable:h=!0,resizable:E=!0,rotatable:d=!0,scalable:T=!1,applyTranslate:p=!1,onInit:u=(()=>{}),onDrop:x=(()=>{}),onMove:_=(()=>{}),onResize:f=(()=>{}),onRotate:m=(()=>{}),onDestroy:y=(()=>{}),container:b=e.parentNode,controlsContainer:M=b,proportions:g=!1,rotatorAnchor:O=null,rotatorOffset:S=50,showNormal:v=!0,custom:R}=t;this.options={axis:a,cursorMove:o,cursorRotate:i,cursorResize:n,rotationPoint:l,restrict:c?helper(c)[0]||document.body:null,container:helper(b)[0],controlsContainer:helper(M)[0],snap:{...s,angle:s.angle*RAD},each:r,proportions:g,draggable:h,resizable:E,rotatable:d,scalable:T,applyTranslate:p,custom:"object"==typeof R&&R||null,rotatorAnchor:O,rotatorOffset:S,showNormal:v},this.proxyMethods={onInit:createMethod(u),onDrop:createMethod(x),onMove:createMethod(_),onResize:createMethod(f),onRotate:createMethod(m),onDestroy:createMethod(y)},this.subscribe(r)}_animate(){const t=this,{observable:e,storage:r,options:s}=t;if(isUndef(r))return;if(r.frame=requestAnimFrame(t._animate),!r.doDraw)return;r.doDraw=!1;let{dox:a,doy:o,clientX:n,clientY:i,doDrag:l,doResize:c,doRotate:h,doSetCenter:E,revX:d,revY:T}=r;const{snap:p,each:{move:u,resize:x,rotate:_},draggable:f,resizable:m,rotatable:y}=s;if(c&&m){const{transform:{scX:s,scY:l},cx:c,cy:h}=r,{x:E,y:u}=this._pointToElement({x:n,y:i});let _=a?snapToGrid(E-c,p.x/s):0,f=o?snapToGrid(u-h,p.y/l):0;const m={dx:_=a?d?-_:_:0,dy:f=o?T?-f:f:0,clientX:n,clientY:i};t._resize(m),x&&e.notify(ON_RESIZE$2,t,m)}if(l&&f){const{nx:s,ny:l}=r,c={dx:a?snapToGrid(n-s,p.x):0,dy:o?snapToGrid(i-l,p.y):0,clientX:n,clientY:i};t._drag(c),u&&e.notify(ON_MOVE$2,t,c)}if(h&&y){const{pressang:s,center:a}=r,o=Math.atan2(i-a.y,n-a.x)-s,l={clientX:n,clientY:i};t._rotate({radians:snapToGrid(o,p.angle),...l}),_&&e.notify(ON_ROTATE$2,t,{radians:o,...l})}if(E&&y){const{bx:e,by:s}=r,{x:a,y:o}=this._pointToControls({x:n,y:i});t._moveCenterHandle(a-e,o-s)}}_start(t){const{clientX:e,clientY:r}=t,{observable:s,storage:a,storage:{handles:o},options:{axis:n,each:i},el:l}=this,c=Object.values(o).some(e=>helper(t.target).is(e))||l.contains(t.target);if(a.isTarget=c,!c)return;const h=this._compute(t,l);Object.keys(h).map(t=>a[t]=h[t]);const{onRightEdge:E,onBottomEdge:d,onTopEdge:T,onLeftEdge:p,handle:u,factor:x,revX:_,revY:f,doW:m,doH:y}=h,b=E||d||T||p,{rotator:M,center:g,radius:O}=o;isDef(O)&&removeClass(O,`${LIB_CLASS_PREFIX}hidden`);const S=u.is(M),v=!!isDef(g)&&u.is(g),R=l.contains(t.target)&&!(S||b||v),{x:N,y:A}=this._cursorPoint({clientX:e,clientY:r}),{x:D,y:$}=this._pointToElement({x:N,y:A}),{x:C,y:I}=this._pointToControls({x:N,y:A}),w={clientX:e,clientY:r,cx:D,cy:$,nx:N,ny:A,bx:C,by:I,doResize:b,doDrag:R,doRotate:S,doSetCenter:v,onExecution:!0,cursor:null,dox:/\x/.test(n)&&(!b||(u.is(o.ml)||u.is(o.mr)||u.is(o.tl)||u.is(o.tr)||u.is(o.bl)||u.is(o.br)||u.is(o.le)||u.is(o.re))),doy:/\y/.test(n)&&(!b||(u.is(o.br)||u.is(o.bl)||u.is(o.bc)||u.is(o.tr)||u.is(o.tl)||u.is(o.tc)||u.is(o.te)||u.is(o.be))),cached:{}};this.storage={...a,...w};const V={clientX:e,clientY:r};b?this._emitEvent(E_RESIZE_START$1,V):S?this._emitEvent(E_ROTATE_START$1,V):R&&this._emitEvent(E_DRAG_START$1,V);const{move:P,resize:G,rotate:L}=i,H=b?E_RESIZE$1:S?E_ROTATE$1:E_DRAG$2,F=b&&G||S&&L||R&&P;s.notify(ON_GETSTATE$2,this,{clientX:e,clientY:r,actionName:H,triggerEvent:F,factor:x,revX:_,revY:f,doW:m,doH:y}),this._draw()}_moving(t){const{storage:e={},options:r}=this;if(!e.isTarget)return;const{x:s,y:a}=this._cursorPoint(t);e.e=t,e.clientX=s,e.clientY=a,e.doDraw=!0;let{doRotate:o,doDrag:n,doResize:i,cursor:l}=e;const{cursorMove:c,cursorResize:h,cursorRotate:E}=r;isUndef(l)&&(n?l=c:o?l=E:i&&(l=h),helper(document.body).css({cursor:l}))}_end({clientX:t,clientY:e}){const{options:{each:r},observable:s,storage:a,storage:{doResize:o,doDrag:n,doRotate:i,frame:l,handles:{radius:c},isTarget:h},proxyMethods:E}=this;if(!h)return;const d=o?E_RESIZE$1:n?E_DRAG$2:E_ROTATE$1;a.doResize=!1,a.doDrag=!1,a.doRotate=!1,a.doSetCenter=!1,a.doDraw=!1,a.onExecution=!1,a.cursor=null,this._apply(d);const T={clientX:t,clientY:e};E.onDrop.call(this,T),o?this._emitEvent(E_RESIZE_END$1,T):i?this._emitEvent(E_ROTATE_END$1,T):n&&this._emitEvent(E_DRAG_END$1,T);const{move:p,resize:u,rotate:x}=r,_=o&&u||i&&x||n&&p;s.notify(ON_APPLY$2,this,{clientX:t,clientY:e,actionName:d,triggerEvent:_}),cancelAnimFrame(l),helper(document.body).css({cursor:"auto"}),isDef(c)&&addClass(c,`${LIB_CLASS_PREFIX}hidden`)}_compute(t,e){const{handles:r}=this.storage,s=helper(t.target),{revX:a,revY:o,doW:n,doH:i,...l}=this._checkHandles(s,r),c=this._getState({revX:a,revY:o,doW:n,doH:i}),{x:h,y:E}=this._cursorPoint(t),d=Math.atan2(E-c.center.y,h-c.center.x);return{...c,...l,handle:Object.values(r).some(e=>helper(t.target).is(e))?s:helper(e),pressang:d}}_checkHandles(t,e){const r=r=>r.some(r=>(e=>!!isDef(e)&&t.is(e))(e[r]));return{revX:r([TOP_LEFT,MIDDLE_LEFT,BOTTOM_LEFT,TOP_CENTER,LEFT_EDGE]),revY:r([TOP_LEFT,TOP_RIGHT,TOP_CENTER,MIDDLE_LEFT,TOP_EDGE]),onTopEdge:r([TOP_CENTER,TOP_RIGHT,TOP_LEFT,TOP_EDGE]),onLeftEdge:r([TOP_LEFT,MIDDLE_LEFT,BOTTOM_LEFT,LEFT_EDGE]),onRightEdge:r([TOP_RIGHT,MIDDLE_RIGHT,BOTTOM_RIGHT,RIGHT_EDGE]),onBottomEdge:r([BOTTOM_RIGHT,BOTTOM_CENTER,BOTTOM_LEFT,BOTTOM_EDGE]),doW:r([MIDDLE_LEFT,MIDDLE_RIGHT,LEFT_EDGE,RIGHT_EDGE]),doH:r([TOP_CENTER,BOTTOM_CENTER,BOTTOM_EDGE,TOP_EDGE])}}_destroy(){const{el:t,storage:{controls:e,wrapper:r}}=this;[t,e].map(t=>helper(t).off(E_MOUSEDOWN$1,this._onMouseDown).off(E_TOUCHSTART$1,this._onTouchStart)),r.parentNode.removeChild(r)}notifyMove(){this._drag(...arguments)}notifyRotate({radians:t,...e}){const{snap:{angle:r}}=this.options;this._rotate({radians:snapToGrid(t,r),...e})}notifyResize(){this._resize(...arguments)}notifyApply({clientX:t,clientY:e,actionName:r,triggerEvent:s}){this.proxyMethods.onDrop.call(this,{clientX:t,clientY:e}),s&&(this._apply(r),this._emitEvent(`${r}End`,{clientX:t,clientY:e}))}notifyGetState({clientX:t,clientY:e,actionName:r,triggerEvent:s,...a}){if(s){const s=this._getState(a);this.storage={...this.storage,...s},this._emitEvent(`${r}Start`,{clientX:t,clientY:e})}}subscribe({resize:t,move:e,rotate:r}){const{observable:s}=this;(e||t||r)&&s.subscribe(ON_GETSTATE$2,this).subscribe(ON_APPLY$2,this),e&&s.subscribe(ON_MOVE$2,this),t&&s.subscribe(ON_RESIZE$2,this),r&&s.subscribe(ON_ROTATE$2,this)}unsubscribe(){const{observable:t}=this;NOTIFIER_EVENTS$1.map(e=>t.unsubscribe(e,this))}disable(){const{storage:t,proxyMethods:e,el:r}=this;isUndef(t)||(t.onExecution&&helper(document).off(E_MOUSEMOVE$2,this._onMouseMove).off(E_MOUSEUP$2,this._onMouseUp).off(E_TOUCHMOVE$2,this._onTouchMove).off(E_TOUCHEND$2,this._onTouchEnd),removeClass(r,`${LIB_CLASS_PREFIX}drag`),this.unsubscribe(),this._destroy(),e.onDestroy.call(this,r),delete this.storage)}exeDrag({dx:t,dy:e}){const{draggable:r}=this.options;r&&(this.storage={...this.storage,...this._getState({revX:!1,revY:!1,doW:!1,doH:!1})},this._drag({dx:t,dy:e}),this._apply(E_DRAG$2))}exeResize({dx:t,dy:e,revX:r=!1,revY:s=!1,doW:a=!1,doH:o=!1}){const{resizable:n}=this.options;n&&(this.storage={...this.storage,...this._getState({revX:r,revY:s,doW:a,doH:o})},this._resize({dx:t,dy:e}),this._apply(E_RESIZE$1))}exeRotate({delta:t}){const{rotatable:e}=this.options;e&&(this.storage={...this.storage,...this._getState({revX:!1,revY:!1,doW:!1,doH:!1})},this._rotate({radians:t}),this._apply(E_ROTATE$1))}}const cloneMatrix=t=>t.map(t=>[...t]),flatMatrix=t=>t.reduce((e,r,s)=>[...e,t[0][s],t[1][s],t[2][s],t[3][s]],[]),createIdentityMatrix=(t=4)=>[...Array(t)].map((t,e,r)=>r.map(()=>+!e--)),createTranslateMatrix=(t,e,r=0)=>createIdentityMatrix().map((s,a)=>(s[3]=[t,e,r,1][a],s)),createScaleMatrix=(t,e,r=1,s=1)=>createIdentityMatrix().map((a,o)=>(a[o]=[t,e,r,s][o],a)),createRotateMatrix=(t,e)=>{const r=createIdentityMatrix();return r[0][0]=e,r[0][1]=-t,r[1][0]=t,r[1][1]=e,r},dropTranslate=(t,e=!0)=>{const r=e?cloneMatrix(t):t;return r[0][3]=r[1][3]=r[2][3]=0,r},multiplyMatrixAndPoint=(t,e)=>{const r=[];for(let s=0,a=t.length;s<a;++s){let o=0;for(let r=0;r<a;++r)o+=+t[s][r]*e[r];r[s]=o}return r},multiplyMatrix=(t,e)=>{const r=[];for(let s=0;s<e.length;s++){r[s]=[];for(let a=0;a<t[0].length;a++){let o=0;for(let r=0;r<t.length;r++)o+=t[r][a]*e[s][r];r[s].push(o)}}return r},matrixInvert=t=>{const e=cloneMatrix(t);let r,s=e.length,a=[];for(let t=0;t<s;t++)a[t]=[];for(let t=0;t<s;t++)for(let e=0;e<s;e++)a[t][e]=0,t==e&&(a[t][e]=1);for(let t=0;t<s;t++){r=e[t][t];for(let o=0;o<s;o++)e[t][o]/=r,a[t][o]/=r;for(let o=t+1;o<s;o++){r=e[o][t];for(let n=0;n<s;n++)e[o][n]-=e[t][n]*r,a[o][n]-=a[t][n]*r}}for(let t=s-1;t>0;t--)for(let o=t-1;o>=0;o--){r=e[o][t];for(let n=0;n<s;n++)e[o][n]-=e[t][n]*r,a[o][n]-=a[t][n]*r}for(let t=0;t<s;t++)for(let r=0;r<s;r++)e[t][r]=a[t][r];return e},computeTransformMatrix=(t,[e,r,s])=>{const a=createTranslateMatrix(-e,-r,-s),o=createTranslateMatrix(e,r,s);return multiplyMatrix(multiplyMatrix(a,t),o)},getCurrentTransformMatrix=(t,e=document.body,r)=>{let s=createIdentityMatrix(),a=t,o=r||getTransform(a),n=!1;for(;a&&a instanceof Element;){const t=getTransformOrigin(a,n);if(s=multiplyMatrix(s,computeTransformMatrix(o,t)),n=!0,a===e||null===a.offsetParent)break;a=a.offsetParent,o=getTransform(a)}return s},decompose=t=>{const e=Math.sqrt(t[0][0]*t[0][0]+t[1][0]*t[1][0]+t[2][0]*t[2][0]),r=Math.sqrt(t[0][1]*t[0][1]+t[1][1]*t[1][1]+t[2][1]*t[2][1]),s=Math.sqrt(t[0][2]*t[0][2]+t[1][2]*t[1][2]+t[2][2]*t[2][2]);let a=Math.atan2(-t[0][3]/s,t[1][3]/s),o=Math.asin(t[3][1]/s),n=Math.atan2(-t[3][0]/r,t[0][0]/e);return 1!==t[0][1]&&-1!==t[0][1]||(a=0,o=t[0][1]*-Math.PI/2,n=t[0][1]*Math.atan2(t[1][1]/r,t[0][1]/r)),{rotate:{x:a,y:o,z:n},translate:{x:t[0][3]/e,y:t[1][3]/r,z:t[2][3]/s},scale:{sX:e,sY:r,sZ:s}}},getTransform=t=>{const e=getStyle(t,"transform")||"none",r=createIdentityMatrix();if("none"===e)return r;const s=e.split(/\s*[(),]\s*/).slice(1,-1);if(16!==s.length)return[[+s[0],+s[2],0,+s[4]],[+s[1],+s[3],0,+s[5]],[0,0,1,0],[0,0,0,1]];for(let t=0;t<4;++t)for(let e=0;e<4;++e)r[e][t]=+s[4*t+e];return r},getTransformOrigin=(t,e)=>{const r=getStyle(t,"transform-origin"),s=r?r.split(" "):[],a=[e?-t.clientLeft:0,e?-t.clientTop:0,0,1];for(let t=0;t<s.length;++t)a[t]+=parseFloat(s[t]);return a},getAbsoluteOffset=(t,e=document.body)=>{let r=0,s=0,a=!1;for(;t;){const o=getCurrentTransformMatrix(t.offsetParent),[n,i]=multiplyMatrixAndPoint(dropTranslate(o,!1),[t.offsetLeft+(a?t.clientLeft:0),t.offsetTop+(a?t.clientTop:0),0,1]);if(s+=n,r+=i,e===t)break;a=!0,t=t.offsetParent}return[s,r,0,1]},{E_MOUSEDOWN:E_MOUSEDOWN$2,E_TOUCHSTART:E_TOUCHSTART$2}=CLIENT_EVENTS_CONSTANTS;class Draggable extends Transformable{_init(t){const{rotationPoint:e,container:r,controlsContainer:s,resizable:a,rotatable:o,showNormal:n,rotatorOffset:i,rotatorAnchor:l}=this.options,{offsetHeight:c,offsetWidth:h}=t,E=createElement(["sjx-wrapper"]),d=createElement(["sjx-controls"]),T={},p=getCurrentTransformMatrix(t,r),[u,x]=getAbsoluteOffset(t,r),_=["data-sjx-cx","data-sjx-cy"].map(e=>{const r=t.getAttribute(e);return isDef(r)?Number(r):void 0}),f=_.every(t=>!isNaN(t)),m={tl:[0,0,0,1],bl:[0,c,0,1],br:[h,c,0,1],tr:[h,0,0,1],tc:[h/2,0,0,1],ml:[0,c/2,0,1],bc:[h/2,c,0,1],mr:[h,c/2,0,1],center:[h/2,c/2,0,1]},y=Object.entries(m).reduce((t,[e,r])=>[...t,[e,multiplyMatrixAndPoint(p,r)]],[]).reduce((t,[e,[r,s,a,o]])=>(t[e]=[r+u,s+x,a,o],t),{});let b={},M=null;if(o){const t={};let r=1;switch(l){case"n":t.x=y.tc[0],t.y=y.tc[1];break;case"s":t.x=y.bc[0],t.y=y.bc[1],r=-1;break;case"w":t.x=y.ml[0],t.y=y.ml[1],r=-1;break;case"e":default:t.x=y.mr[0],t.y=y.mr[1]}const s="n"===l||"s"===l?Math.atan2(y.bl[1]-y.tl[1],y.bl[0]-y.tl[0]):Math.atan2(y.tl[1]-y.tr[1],y.tl[0]-y.tr[0]);M=[t.x-i*r*Math.cos(s),t.y-i*r*Math.sin(s)];const a=n?renderLine([[t.x,t.y],M]):null;n&&d.appendChild(a);let o=null;e&&(o=renderLine([y.center,y.center]),addClass(o,"sjx-hidden"),d.appendChild(o)),b={...b,normal:a,radius:o}}const g={te:[y.tl,y.tr],be:[y.bl,y.br],le:[y.tl,y.bl],re:[y.tr,y.br]},O=a?{tl:y.tl,tr:y.tr,br:y.br,bl:y.bl,tc:y.tc,bc:y.bc,ml:y.ml,mr:y.mr}:{},S=f?[..._,0,1]:y.center,v={...O,center:e&&o?S:void 0,rotator:M},R=(t,e)=>Object.keys(t).map(r=>{const s=t[r];if(isUndef(s))return;const a=e(s,r);T[r]=a,d.appendChild(a)});R(g,renderLine),R(v,createHandler),E.appendChild(d),s.appendChild(E),this.storage={wrapper:E,controls:d,handles:{...T,...b},parent:t.parentNode,center:{isShifted:f},cached:{}},[t,d].map(t=>helper(t).on(E_MOUSEDOWN$2,this._onMouseDown).on(E_TOUCHSTART$2,this._onTouchStart))}_pointToElement({x:t,y:e}){const{transform:{ctm:r}}=this.storage,s=matrixInvert(r);return this._applyMatrixToPoint(dropTranslate(s,!1),t,e)}_pointToControls({x:t,y:e}){const{transform:{wrapperMatrix:r}}=this.storage,s=matrixInvert(r);return this._applyMatrixToPoint(dropTranslate(s,!1),t,e)}_applyMatrixToPoint(t,e,r){const[s,a]=multiplyMatrixAndPoint(t,[e,r,0,1]);return{x:s,y:a}}_cursorPoint({clientX:t,clientY:e}){const{container:r}=this.options,s=getCurrentTransformMatrix(r);return this._applyMatrixToPoint(matrixInvert(s),t,e)}_restrictHandler(t){const{storage:{transform:{containerMatrix:e}},options:{restrict:r,container:s}}=this;let a=null,o=null;const n=getBoundingRect(r,s,e),i=this.getBoundingRect(t),[l,c]=getMinMaxOf2DIndex(n,0),[h,E]=getMinMaxOf2DIndex(n,1);for(let t=0,e=i.length;t<e;t++){const[e,r]=i[t];(e<l||e>c)&&(a=e),(r<h||r>E)&&(o=r)}return{x:a,y:o}}_apply(){const{el:t,storage:{cached:e,controls:r,transform:{matrix:s},center:a},options:{applyTranslate:o}}=this,n=helper(r);if(!isUndef(e)){if(t.setAttribute("data-sjx-cx",a.elX),t.setAttribute("data-sjx-cy",a.elY),o){const r=helper(t),{dx:a,dy:o}=e,i=matrixToCSS(s),l=parseFloat(t.style.left||r.css("left")),c=parseFloat(t.style.top||r.css("top"));i.left=`${l+a}px`,i.top=`${c+o}px`,r.css(i),n.css(i)}this.storage.cached={}}}_processResize(t,e){const{el:r,storage:s,storage:{transform:{matrix:a,auxiliary:{scale:{translateMatrix:o}}},cached:{dist:{dx:n=t,dy:i=e}={}}={},box:{width:l,height:c},revX:h,revY:E,doW:d,doH:T},options:{proportions:p,scalable:u,restrict:x}}=this,_=(t,e)=>{const r=d||!d&&!T?(l+t)/l:(c+e)/c,s=p?l*r:l+t,a=p?c*r:c+e;return[s/l,a/c,s,a]},f=(t,e)=>{const r=createScaleMatrix(t,e);return multiplyMatrix(multiplyMatrix(o,r),matrixInvert(o))},m=(t,e)=>{const r=t[0][3],s=t[1][3],a=createTranslateMatrix(r,s),o=createTranslateMatrix(r*(h?-1:1),s*(E?-1:1));return multiplyMatrix(multiplyMatrix(o,e),matrixInvert(a))},[y,b,M,g]=_(t,e),O=f(y,b),S=u?multiplyMatrix(O,a):m(O,a);this.storage.cached.box={width:M,height:g};const{x:v,y:R}=x?this._restrictHandler(S):{x:null,y:null},N=(null!==v||null!==R)&&x,A=N?n:t,D=N?i:e,[$,C,I,w]=_(A,D);if(Math.abs(I)<=MIN_SIZE||Math.abs(w)<=MIN_SIZE)return;const V=f($,C),P=u?multiplyMatrix(V,a):m(V,a);return helper(r).css({...matrixToCSS(flatMatrix(P)),...!u&&{width:`${I}px`,height:`${w}px`}}),applyTransformToHandles(s,this.options,{el:r,boxMatrix:P}),s.cached.dist={dx:A,dy:D},{transform:P,width:I,height:w}}_processMove(t,e){const{el:r,storage:s,storage:{wrapper:a,transform:{matrix:o,wrapperMatrix:n,auxiliary:{translate:{parentMatrix:i}}},center:l,cached:{dist:{dx:c=t,dy:h=e}={}}={}},options:{restrict:E}}=this,[d,T]=multiplyMatrixAndPoint(i,[t,e,0,1]),p=multiplyMatrix(o,createTranslateMatrix(d,T)),{x:u,y:x}=E?this._restrictHandler(p):{x:null,y:null},_=null!==u&&E?c:t,f=null!==x&&E?h:e,[m,y]=multiplyMatrixAndPoint(i,[_,f,0,1]),b=multiplyMatrix(o,createTranslateMatrix(m,y)),M=multiplyMatrix(n,createTranslateMatrix(_,f)),g=matrixToCSS(flatMatrix(b)),O=matrixToCSS(flatMatrix(M));return helper(r).css(g),helper(a).css(O),s.cached.dist={dx:_,dy:f},l.isShifted,b}_processRotate(t){const{el:e,storage:{transform:{matrix:r,auxiliary:{rotate:{translateMatrix:s}}}},options:{restrict:a}}=this,o=floatToFixed(Math.cos(t),4),n=floatToFixed(Math.sin(t),4),i=createRotateMatrix(n,o),l=multiplyMatrix(multiplyMatrix(matrixInvert(s),i),s),c=multiplyMatrix(r,l),{x:h,y:E}=a?this._restrictHandler(c):{x:null,y:null};return isDef(h)||isDef(E)?c:(helper(e).css(matrixToCSS(flatMatrix(c))),applyTransformToHandles(this.storage,this.options,{el:e,boxMatrix:c}),c)}_getState({revX:t,revY:e,doW:r,doH:s}){const{el:a,storage:{handles:{center:o},parent:n,wrapper:i,center:l},options:{container:c,restrict:h,scalable:E}}=this,{offsetWidth:d,offsetHeight:T}=h||c,[p,u]=getAbsoluteOffset(a,c),{offsetLeft:x,offsetTop:_,offsetWidth:f,offsetHeight:m}=a,y=getTransform(a),b=getCurrentTransformMatrix(a,c),M=getCurrentTransformMatrix(n,c),g=getCurrentTransformMatrix(i,c),O=h?getCurrentTransformMatrix(h,h.parentNode):getCurrentTransformMatrix(c,c.parentNode),S=f/2,v=m/2,R=s?0:t?-S:S,N=r?0:e?-v:v,[A,D]=multiplyMatrixAndPoint(b,[S,v,0,1]),$=A+p,C=D+u,I=o?getTransform(o):createIdentityMatrix(),{translate:{x:w,y:V}}=o?decompose(getCurrentTransformMatrix(o)):{translate:{x:$,y:C}},[P,G]=multiplyMatrixAndPoint(multiplyMatrix(matrixInvert(dropTranslate(b)),dropTranslate(I)),[w-$,V-C,0,1]),[L,H]=multiplyMatrixAndPoint(y,[P,G,0,1]),F=multiplyMatrixAndPoint(dropTranslate(O),[d,T,0,1]),{scale:{sX:U,sY:k}}=decompose(getCurrentTransformMatrix(a,a.parentNode));return{transform:{auxiliary:{scale:{translateMatrix:E?createTranslateMatrix(R,N):createTranslateMatrix(s?0:S,r?0:v)},translate:{parentMatrix:matrixInvert(dropTranslate(M))},rotate:{translateMatrix:createTranslateMatrix(L,H)}},scaleX:R,scaleY:N,matrix:y,ctm:b,parentMatrix:M,containerMatrix:O,wrapperMatrix:g,scX:U,scY:k,containerBox:F},box:{width:f,height:m,left:x,top:_,offset:{left:p,top:u}},center:{...l,x:$,y:C,elX:L,elY:H,matrix:I},revX:t,revY:e,doW:r,doH:s}}_moveCenterHandle(t,e){const{storage:{handles:{center:r},center:{matrix:s}}}=this,a=multiplyMatrix(s,createTranslateMatrix(t,e));helper(r).css({...matrixToCSS(flatMatrix(a))}),this.storage.center.isShifted=!0}resetCenterPoint(){const{el:t,el:{offsetHeight:e,offsetWidth:r},storage:{wrapper:s,handles:{center:a}},options:{container:o}}=this;if(!a)return;const[n,i]=getAbsoluteOffset(t,o),l=multiplyMatrix(getCurrentTransformMatrix(t,o),matrixInvert(getCurrentTransformMatrix(s,s.parentNode))),[c,h]=multiplyMatrixAndPoint(l,[r/2,e/2,0,1]);helper(a).css({transform:`translate(${c+n}px, ${h+i}px)`})}fitControlsToSize(){const{el:t,storage:{wrapper:e}}=this;e.removeAttribute("transform"),applyTransformToHandles(this.storage,this.options,{el:t})}getBoundingRect(t=null){const{el:e,options:{scalable:r,restrict:s},storage:{box:a,box:{width:o,height:n},cached:{box:{width:i=o,height:l=n}={}}={}}}=this,c=r?a:{...a,width:i,height:l};return getBoundingRect(e,s,getCurrentTransformMatrix(e,s,t),c)}get controls(){return this.storage.wrapper}}const createHandler=([t,e],r="handler",s={})=>{const a=createElement(["sjx-hdl",`sjx-hdl-${r}`]);return helper(a).css({transform:`translate(${t}px, ${e}px)`,...s}),a},renderLine=([t,e,r=1],s)=>{const{cx:a,cy:o,length:n,theta:i}=getLineAttrs(t,e,r),l=createElement(["sjx-hdl-line",`sjx-hdl-${s}`]);return helper(l).css({transform:`translate(${a}px, ${o}px) rotate(${i}deg)`,height:`${r}px`,width:`${n}px`}),l},getLineAttrs=(t,e,r=1)=>{const[s,a]=t,[o,n]=e,i=Math.sqrt((o-s)*(o-s)+(n-a)*(n-a));return{cx:(s+o)/2-i/2,cy:(a+n)/2-r/2,thickness:r,theta:Math.atan2(a-n,s-o)*(180/Math.PI),length:i}},applyTransformToHandles=(t,e,r)=>{const{wrapper:s,handles:a,transform:{wrapperMatrix:o=getCurrentTransformMatrix(s,s.parentNode)}={},center:n}=t,{rotationPoint:i,rotatable:l,resizable:c,showNormal:h,rotatorOffset:E,rotatorAnchor:d,container:T}=e,{el:p,el:{offsetHeight:u,offsetWidth:x}}=r,[_,f]=getAbsoluteOffset(p,T),m=multiplyMatrix(getCurrentTransformMatrix(p,T),matrixInvert(o)),y={tl:[0,0,0,1],tr:[x,0,0,1],bl:[0,u,0,1],br:[x,u,0,1],tc:[x/2,0,0,1],ml:[0,u/2,0,1],bc:[x/2,u,0,1],mr:[x,u/2,0,1],...i&&l&&!n.isShifted&&{center:[x/2,u/2,0,1]}},b=Object.entries(y).reduce((t,[e,r])=>[...t,[e,multiplyMatrixAndPoint(m,r)]],[]).reduce((t,[e,[r,s,a,o]])=>(t[e]=[r+_,s+f,a,o],t),{});let M=null,g={};if(l){const t={};let e=1,r=[];switch(d){case"n":t.x=b.tc[0],t.y=b.tc[1];break;case"s":t.x=b.bc[0],t.y=b.bc[1],e=-1;break;case"w":t.x=b.ml[0],t.y=b.ml[1],e=-1;break;case"e":default:t.x=b.mr[0],t.y=b.mr[1]}const s="n"===d||"s"===d?Math.atan2(b.bl[1]-b.tl[1],b.bl[0]-b.tl[0]):Math.atan2(b.tl[1]-b.tr[1],b.tl[0]-b.tr[0]),a=E*e;r=[t.x-a*Math.cos(s),t.y-a*Math.sin(s)],M=h?[[t.x,t.y],r]:null,g={rotator:r}}const O={...b},S={te:[b.tl,b.tr],be:[b.bl,b.br],le:[b.tl,b.bl],re:[b.tr,b.br],...h&&M&&{normal:M}};Object.keys(S).forEach(t=>{const[e,r]=S[t],{cx:s,cy:o,length:n,theta:i}=getLineAttrs(e,r);helper(a[t]).css({transform:`translate(${s}px, ${o}px) rotate(${i}deg)`,width:`${n}px`})});const v={...c&&O,...g};Object.keys(v).forEach(t=>{const e=v[t];if(!e)return;const[r,s]=e;helper(a[t]).css({transform:`translate(${r}px, ${s}px)`})})},getBoundingRect=(t,e,r,s)=>{const[a,o]=getAbsoluteOffset(t,e),{width:n,height:i,offset:{left:l,top:c}}=s||{width:t.offsetWidth,height:t.offsetHeight,offset:{left:a,top:o}};return[[0,0,0,1],[n,0,0,1],[0,i,0,1],[n,i,0,1]].reduce((t,e)=>[...t,multiplyMatrixAndPoint(r,e)],[]).map(([t,e,r,s])=>[t+l,e+c,r,s])},createElement=(t=[])=>{const e=document.createElement("div");return t.forEach(t=>addClass(e,t)),e},svgPoint=createSVGElement("svg").createSVGPoint(),floatRE=/[+-]?\d+(\.\d+)?/g,allowedElements=["circle","ellipse","image","line","path","polygon","polyline","rect","text","g","foreignobject","use"];function createSVGElement(t,e=[]){const r=document.createElementNS("http://www.w3.org/2000/svg",t);return e.forEach(t=>addClass(r,t)),r}const checkChildElements=t=>{const e=[];return isGroup(t)?forEach.call(t.childNodes,t=>{if(1===t.nodeType){const r=t.tagName.toLowerCase();-1!==allowedElements.indexOf(r)&&("g"===r&&e.push(...checkChildElements(t)),e.push(t))}}):e.push(t),e},createSVGMatrix=()=>createSVGElement("svg").createSVGMatrix(),createTranslateMatrix$1=(t,e)=>{const r=createSVGMatrix();return r.e=t,r.f=e,r},createRotateMatrix$1=(t,e)=>{const r=createSVGMatrix();return r.a=e,r.b=t,r.c=-t,r.d=e,r},createScaleMatrix$1=(t,e)=>{const r=createSVGMatrix();return r.a=t,r.d=e,r},getTransformToElement=(t,e)=>{return(e.getScreenCTM&&e.getScreenCTM()||createSVGMatrix()).inverse().multiply(t.getScreenCTM()||createSVGMatrix())},matrixToString=t=>{const{a:e,b:r,c:s,d:a,e:o,f:n}=t;return`matrix(${e},${r},${s},${a},${o},${n})`},pointTo=(t,e,r)=>(svgPoint.x=e,svgPoint.y=r,svgPoint.matrixTransform(t)),cloneMatrix$1=t=>{const e=createSVGMatrix();return e.a=t.a,e.b=t.b,e.c=t.c,e.d=t.d,e.e=t.e,e.f=t.f,e},isIdentity=t=>{const{a:e,b:r,c:s,d:a,e:o,f:n}=t;return 1===e&&0===r&&0===s&&1===a&&0===o&&0===n},checkElement=t=>{const e=t.tagName.toLowerCase();return-1!==allowedElements.indexOf(e)||(warn(`Selected element "${e}" is not allowed to transform. Allowed elements:\n\n            circle, ellipse, image, line, path, polygon, polyline, rect, text, g`),!1)},isGroup=t=>"g"===t.tagName.toLowerCase(),parsePoints=t=>t.match(floatRE).reduce((t,e,r,s)=>(r%2==0&&t.push(s.slice(r,r+2)),t),[]),dRE=/\s*([achlmqstvz])([^achlmqstvz]*)\s*/gi,sepRE=/\s*,\s*|\s+/g,parsePath=t=>{let e=dRE.lastIndex=0;const r=[];for(;e=dRE.exec(t);){const[,t,s]=e,a=t.toUpperCase(),o=s.replace(/([^e])-/g,"$1 -").replace(/ +/g," ");r.push({relative:t!==a,key:a,cmd:t,values:o.trim().split(sepRE).map(t=>{if(!isNaN(t))return Number(t)})})}return r},movePath=t=>{const{path:e,dx:r,dy:s}=t;try{const t=parsePath(e);let a="",o=" ",n=!0;for(let e=0,i=t.length;e<i;e++){const i=t[e],{values:l,key:c,relative:h}=i,E=[];switch(c){case"M":for(let t=0,e=l.length;t<e;t+=2){let[e,a]=l.slice(t,t+2);h&&!n||(e+=r,a+=s),E.push(e,a),n=!1}break;case"A":for(let t=0,e=l.length;t<e;t+=7){const e=l.slice(t,t+7);h||(e[5]+=r,e[6]+=s),E.push(...e)}break;case"C":for(let t=0,e=l.length;t<e;t+=6){const e=l.slice(t,t+6);h||(e[0]+=r,e[1]+=s,e[2]+=r,e[3]+=s,e[4]+=r,e[5]+=s),E.push(...e)}break;case"H":for(let t=0,e=l.length;t<e;t+=1){const e=l.slice(t,t+1);h||(e[0]+=r),E.push(e[0])}break;case"V":for(let t=0,e=l.length;t<e;t+=1){const e=l.slice(t,t+1);h||(e[0]+=s),E.push(e[0])}break;case"L":case"T":for(let t=0,e=l.length;t<e;t+=2){let[e,a]=l.slice(t,t+2);h||(e+=r,a+=s),E.push(e,a)}break;case"Q":case"S":for(let t=0,e=l.length;t<e;t+=4){let[e,a,o,n]=l.slice(t,t+4);h||(e+=r,a+=s,o+=r,n+=s),E.push(e,a,o,n)}break;case"Z":l[0]="",o=""}a+=i.cmd+E.join(",")+o}return a}catch(t){warn("Path parsing error: "+t)}},resizePath=t=>{const{path:e,localCTM:r}=t;try{const t=parsePath(e);let s="",a=" ";const o=[];let n=!0;for(let e=0,i=t.length;e<i;e++){const i=t[e],{values:l,key:c,relative:h}=i;switch(c){case"A":{const t=[];for(let e=0,s=l.length;e<s;e+=7){const[s,a,o,n,i,c,E]=l.slice(e,e+7),d=cloneMatrix$1(r);h&&(d.e=d.f=0);const{x:T,y:p}=pointTo(d,c,E);t.push(floatToFixed(T),floatToFixed(p)),d.e=d.f=0;const{x:u,y:x}=pointTo(d,s,a);t.unshift(floatToFixed(u),floatToFixed(x),o,n,i)}o.push(t);break}case"C":{const t=[];for(let e=0,s=l.length;e<s;e+=6){const[s,a,o,n,i,c]=l.slice(e,e+6),E=cloneMatrix$1(r);h&&(E.e=E.f=0);const{x:d,y:T}=pointTo(E,s,a),{x:p,y:u}=pointTo(E,o,n),{x:x,y:_}=pointTo(E,i,c);t.push(floatToFixed(d),floatToFixed(T),floatToFixed(p),floatToFixed(u),floatToFixed(x),floatToFixed(_))}o.push(t);break}case"H":{const t=[];for(let e=0,s=l.length;e<s;e+=1){const[s]=l.slice(e,e+1),a=cloneMatrix$1(r);h&&(a.e=a.f=0);const{x:o}=pointTo(a,s,0);t.push(floatToFixed(o))}o.push(t);break}case"V":{const t=[];for(let e=0,s=l.length;e<s;e+=1){const[s]=l.slice(e,e+1),a=cloneMatrix$1(r);h&&(a.e=a.f=0);const{y:o}=pointTo(a,0,s);t.push(floatToFixed(o))}o.push(t);break}case"T":case"L":{const t=[];for(let e=0,s=l.length;e<s;e+=2){const[s,a]=l.slice(e,e+2),o=cloneMatrix$1(r);h&&(o.e=o.f=0);const{x:n,y:i}=pointTo(o,s,a);t.push(floatToFixed(n),floatToFixed(i))}o.push(t);break}case"M":{const t=[];for(let e=0,s=l.length;e<s;e+=2){const[s,a]=l.slice(e,e+2),o=cloneMatrix$1(r);h&&!n&&(o.e=o.f=0);const{x:i,y:c}=pointTo(o,s,a);t.push(floatToFixed(i),floatToFixed(c)),n=!1}o.push(t);break}case"Q":{const t=[];for(let e=0,s=l.length;e<s;e+=4){const[s,a,o,n]=l.slice(e,e+4),i=cloneMatrix$1(r);h&&(i.e=i.f=0);const{x:c,y:E}=pointTo(i,s,a),{x:d,y:T}=pointTo(i,o,n);t.push(floatToFixed(c),floatToFixed(E),floatToFixed(d),floatToFixed(T))}o.push(t);break}case"S":{const t=[];for(let e=0,s=l.length;e<s;e+=4){const[s,a,o,n]=l.slice(e,e+4),i=cloneMatrix$1(r);h&&(i.e=i.f=0);const{x:c,y:E}=pointTo(i,s,a),{x:d,y:T}=pointTo(i,o,n);t.push(floatToFixed(c),floatToFixed(E),floatToFixed(d),floatToFixed(T))}o.push(t);break}case"Z":o.push([""]),a=""}s+=i.cmd+o[e].join(",")+a}return s}catch(t){warn("Path parsing error: "+t)}},{E_DRAG:E_DRAG$3,E_RESIZE:E_RESIZE$2}=EVENT_EMITTER_CONSTANTS,{E_MOUSEDOWN:E_MOUSEDOWN$3,E_TOUCHSTART:E_TOUCHSTART$3}=CLIENT_EVENTS_CONSTANTS;class DraggableSVG extends Transformable{_init(t){const{rotationPoint:e,container:r,controlsContainer:s,resizable:a,rotatable:o,rotatorAnchor:n,rotatorOffset:i,showNormal:l,custom:c}=this.options,h=t.getBBox(),{x:E,y:d,width:T,height:p}=h,u=createSVGElement("g",["sjx-svg-wrapper"]),x=createSVGElement("g",["sjx-svg-controls"]),_=["data-sjx-cx","data-sjx-cy"].map(e=>{const r=t.getAttribute(e);return isDef(r)?Number(r):void 0}),f=_.every(t=>!isNaN(t)),m={tl:[E,d],tr:[E+T,d],mr:[E+T,d+p/2],ml:[E,d+p/2],tc:[E+T/2,d],bc:[E+T/2,d+p],br:[E+T,d+p],bl:[E,d+p],center:[E+T/2,d+p/2]},y=getTransformToElement(t,r),b=Object.entries(m).reduce((t,[e,[r,s]])=>({...t,[e]:pointTo(y,r,s)}),{}),M={};let g={},O=null;if(o){const t={};let r=1;switch(n){case"n":t.x=b.tc.x,t.y=b.tc.y;break;case"s":t.x=b.bc.x,t.y=b.bc.y,r=-1;break;case"w":t.x=b.ml.x,t.y=b.ml.y,r=-1;break;case"e":default:t.x=b.mr.x,t.y=b.mr.y}const s="n"===n||"s"===n?Math.atan2(b.bl.y-b.tl.y,b.bl.x-b.tl.x):Math.atan2(b.tl.y-b.tr.y,b.tl.x-b.tr.x);O={x:t.x-i*r*Math.cos(s),y:t.y-i*r*Math.sin(s)};const a=l?renderLine$1([t,O],THEME_COLOR,"norm"):null;l&&x.appendChild(a);let o=null;e&&((o=createSVGElement("line",["sjx-hidden"])).x1.baseVal.value=b.center.x,o.y1.baseVal.value=b.center.y,o.x2.baseVal.value=_[0]||b.center.x,o.y2.baseVal.value=_[1]||b.center.y,setLineStyle(o,"#fe3232"),o.setAttribute("opacity",.5),x.appendChild(o)),g={...g,normal:a,radius:o}}const S=a?{...b,rotator:O}:{},v={te:[S.tl,S.tr],be:[S.bl,S.br],le:[S.tl,S.bl],re:[S.tr,S.br]};Object.keys(v).forEach(t=>{const e=v[t];isUndef(e)||(M[t]=renderLine$1(e,THEME_COLOR,t),x.appendChild(M[t]))});const R=f?pointTo(createSVGMatrix(),_[0],_[1]):b.center,N={...S,center:e&&o?R:void 0};Object.keys(N).forEach(t=>{const e=N[t];if(isUndef(e))return;const{x:r,y:s}=e,a="center"===t?"#fe3232":THEME_COLOR;isDef(c)&&isFunc(c[t])?M[t]=c[t](y,h,pointTo):M[t]=createHandler$1(r,s,a,t),x.appendChild(M[t])}),u.appendChild(x),s.appendChild(u),this.storage={wrapper:u,controls:x,handles:{...M,...g},parent:t.parentNode,center:{isShifted:f},cached:{}},[t,x].map(t=>helper(t).on(E_MOUSEDOWN$3,this._onMouseDown).on(E_TOUCHSTART$3,this._onTouchStart))}_cursorPoint({clientX:t,clientY:e}){const{container:r}=this.options;return this._applyMatrixToPoint(r.getScreenCTM().inverse(),t,e)}_restrictHandler(t){const{storage:{transform:{containerMatrix:e}},options:{container:r,restrict:s=r}}=this;let a=null,o=null;const n=getBoundingRect$1(s,e),i=this.getBoundingRect(t),[l,c]=getMinMaxOf2DIndex(n,0),[h,E]=getMinMaxOf2DIndex(n,1);for(let t=0,e=i.length;t<e;t++){const[e,r]=i[t];(e<l||e>c)&&(a=e),(r<h||r>E)&&(o=r)}return{x:a,y:o}}_pointToElement({x:t,y:e}){const{transform:{ctm:r}}=this.storage,s=r.inverse();return s.e=s.f=0,this._applyMatrixToPoint(s,t,e)}_pointToControls({x:t,y:e}){const{transform:{wrapperMatrix:r}}=this.storage,s=r.inverse();return s.e=s.f=0,this._applyMatrixToPoint(s,t,e)}_applyMatrixToPoint(t,e,r){const s=createSVGElement("svg").createSVGPoint();return s.x=e,s.y=r,s.matrixTransform(t)}_apply(t){const{el:e,storage:r,storage:{bBox:s,cached:a,transform:o,center:n},options:i,options:{container:l,scalable:c,applyTranslate:h}}=this,{matrix:E,parentMatrix:d,ctm:T}=o;if(e.setAttribute("data-sjx-cx",n.elX),e.setAttribute("data-sjx-cy",n.elY),isUndef(a))return;const{scaleX:p,scaleY:u,dx:x,dy:_,ox:f,oy:m,transformMatrix:y}=a;if(t===E_DRAG$3){if(!h||0===x&&0===_)return;const t=createTranslateMatrix$1(x,_),r=t.multiply(E).multiply(t.inverse());if(e.setAttribute("transform",matrixToString(r)),isGroup(e)){checkChildElements(e).forEach(t=>{const e=createTranslateMatrix$1(x,_),r=e.multiply(getTransformToElement(t,t.parentNode)).multiply(e.inverse());if(isIdentity(r)||t.setAttribute("transform",matrixToString(r)),!isGroup(t)){const e=d.inverse();e.e=e.f=0,applyTranslate(t,{...pointTo(e,f,m)})}})}else applyTranslate(e,{x:x,y:_})}if(t===E_RESIZE$2){if(!y)return;if(!c)if(isGroup(e)){checkChildElements(e).forEach(t=>{if(!isGroup(t)){const o=getTransformToElement(t,e),n=o.inverse().multiply(y).multiply(o);applyResize(t,{scaleX:p,scaleY:u,localCTM:n,bBox:s,container:l,storage:r,cached:a})}})}else{const t=l.getScreenCTM()||createSVGMatrix(),o=e.getScreenCTM().multiply(y),n=t.inverse().multiply(o),i=T.inverse().multiply(n);applyResize(e,{scaleX:p,scaleY:u,localCTM:i,bBox:s,container:l,storage:r,cached:a})}applyTransformToHandles$1(r,i,{boxMatrix:c?T.multiply(y):T,element:e})}}_processResize(t,e){const{el:r,storage:s,storage:{bBox:{width:a,height:o},revX:n,revY:i,doW:l,doH:c,transform:{matrix:h,auxiliary:{scale:{translateMatrix:E}}},cached:{dist:{dx:d=t,dy:T=e}={}}={}},options:{proportions:p,scalable:u,restrict:x}}=this,{x:_,y:f}=r.getBBox(),m=(t,e)=>{const r=l||!l&&!c?(a+t)/a:(o+e)/o,s=p?a*r:a+t,n=p?o*r:o+e;return[s/a,n/o,s,n]},y=(t,e)=>{const r=createScaleMatrix$1(t,e);return E.multiply(r).multiply(E.inverse())},b=h.multiply(y(...m(t,e))),{x:M,y:g}=x?this._restrictHandler(b):{x:null,y:null},O=(null!==M||null!==g)&&x,S=O?d:t,v=O?T:e,[R,N,A,D]=m(S,v);if(Math.abs(A)<=MIN_SIZE||Math.abs(D)<=MIN_SIZE)return;const $=y(R,N),C=h.multiply($),I=_-(A-a)*(c?.5:n?1:0),w=f-(D-o)*(l?.5:i?1:0);return u&&r.setAttribute("transform",matrixToString(C)),s.cached={...s.cached,scaleX:R,scaleY:N,transformMatrix:$,resultMatrix:C,dist:{dx:S,dy:v}},this._apply(E_RESIZE$2),{x:I,y:w,width:A,height:D,transform:C}}_processMove(t,e){const{storage:r,storage:{wrapper:s,center:a,transform:{matrix:o,auxiliary:{translate:{translateMatrix:n,wrapperTranslateMatrix:i}},wrapperMatrix:l,parentMatrix:c},cached:{dist:{dx:h=t,dy:E=e}={}}={}},options:{restrict:d}}=this;c.e=c.f=0;const{x:T,y:p}=pointTo(c.inverse(),t,e),u=createTranslateMatrix$1(T,p).multiply(o),{x:x,y:_}=d?this._restrictHandler(u):{x:null,y:null};r.cached.dist={dx:null!==x&&d?h:t,dy:null!==_&&d?E:e};const{x:f,y:m}=pointTo(c.inverse(),h,E);n.e=f,n.f=m;const y=n.multiply(o);i.e=h,i.f=E;const b=i.multiply(l);if(s.setAttribute("transform",matrixToString(b)),this.el.setAttribute("transform",matrixToString(y)),a.isShifted){const t=l.inverse();t.e=t.f=0;const{x:e,y:r}=pointTo(t,h,E);this._moveCenterHandle(-e,-r)}return y}_processRotate(t){const{storage:{wrapper:e,transform:{matrix:r,wrapperMatrix:s,parentMatrix:a,auxiliary:{rotate:{translateMatrix:o,wrapperTranslateMatrix:n}}}},options:{restrict:i}}=this,l=floatToFixed(Math.cos(t)),c=floatToFixed(Math.sin(t)),h=createRotateMatrix$1(c,l);a.e=a.f=0;const E=a.inverse().multiply(h).multiply(a),d=o.multiply(E).multiply(o.inverse()).multiply(r),{x:T,y:p}=i?this._restrictHandler(d):{x:null,y:null};if(isDef(T)||isDef(p))return d;const u=n.multiply(h).multiply(n.inverse()).multiply(s);return e.setAttribute("transform",matrixToString(u)),this.el.setAttribute("transform",matrixToString(d)),d}_getState({revX:t,revY:e,doW:r,doH:s}){const{el:a,storage:{wrapper:o,parent:n,handles:{center:i}},options:{container:l,restrict:c,rotationPoint:h}}=this,E=a.getBBox(),{x:d,y:T,width:p,height:u}=E,x=getTransformToElement(a,n),_=getTransformToElement(a,l),f=getTransformToElement(o,l),m=getTransformToElement(n,l),y=getTransformToElement(o,o.parentNode),b=m.inverse(),M=d+p*(s?.5:t?1:0),g=T+u*(r?.5:e?1:0),O=d+p/2,S=T+u/2,v=h?i.cx.baseVal.value:O,R=h?i.cy.baseVal.value:S,{x:N,y:A}=pointTo(f,v,R),{x:D,y:$}=h?pointTo(b,N,A):pointTo(x,O,S),{x:C,y:I}=pointTo(_,O,S);storeElementAttributes(this.el),checkChildElements(a).forEach(t=>{t.__ctm__=getTransformToElement(t,t.parentNode),storeElementAttributes(t)});const w={...this.storage.center||{},x:h?N:C,y:h?A:I,elX:D,elY:$,hx:h?i.cx.baseVal.value:null,hy:h?i.cy.baseVal.value:null},V=c?getTransformToElement(c,c.parentNode):getTransformToElement(l,l.parentNode);return{transform:{auxiliary:{scale:{scaleMatrix:createSVGMatrix(),translateMatrix:createTranslateMatrix$1(M,g)},translate:{parentMatrix:b,translateMatrix:createSVGMatrix(),wrapperTranslateMatrix:createSVGMatrix()},rotate:{translateMatrix:createTranslateMatrix$1(w.elX,w.elY),wrapperTranslateMatrix:createTranslateMatrix$1(w.x,w.y)}},matrix:x,ctm:_,parentMatrix:m,wrapperMatrix:y,containerMatrix:V,scX:Math.sqrt(_.a*_.a+_.b*_.b),scY:Math.sqrt(_.c*_.c+_.d*_.d)},bBox:E,center:w,revX:t,revY:e,doW:r,doH:s}}_moveCenterHandle(t,e){const{handles:{center:r,radius:s},center:{hx:a,hy:o}}=this.storage;if(isUndef(r))return;const n=a+t,i=o+e;r.cx.baseVal.value=n,r.cy.baseVal.value=i,s.x2.baseVal.value=n,s.y2.baseVal.value=i,this.storage.center.isShifted=!0}resetCenterPoint(){const{el:t,storage:{bBox:{width:e,height:r,x:s,y:a},handles:{center:o,radius:n}}}=this;if(!o)return;const i=getTransformToElement(t,t.parentNode),{x:l,y:c}=pointTo(i,s+e/2,a+r/2);o.cx.baseVal.value=l,o.cy.baseVal.value=c,o.isShifted=!1,n.x2.baseVal.value=l,n.y2.baseVal.value=c}fitControlsToSize(){const{el:t,storage:{wrapper:e},options:{container:r}}=this,{width:s,height:a,x:o,y:n}=t.getBBox(),i=getTransformToElement(t,r),l=createSVGMatrix();this.storage.transform.wrapperMatrix=l,e.setAttribute("transform",matrixToString(l)),applyTransformToHandles$1(this.storage,this.options,{x:o,y:n,width:s,height:a,boxMatrix:i,element:t})}getBoundingRect(t){const{el:e,options:{restrict:r},storage:{bBox:s}}=this;return getBoundingRect$1(e,getTransformToElement(e.parentNode,r).multiply(t),s)}get controls(){return this.storage.wrapper}}const applyTranslate=(t,{x:e,y:r})=>{const s=[];switch(t.tagName.toLowerCase()){case"text":{const a=isDef(t.x.baseVal[0])?t.x.baseVal[0].value+e:(Number(t.getAttribute("x"))||0)+e,o=isDef(t.y.baseVal[0])?t.y.baseVal[0].value+r:(Number(t.getAttribute("y"))||0)+r;s.push(["x",a],["y",o]);break}case"foreignobject":case"use":case"image":case"rect":{const a=isDef(t.x.baseVal.value)?t.x.baseVal.value+e:(Number(t.getAttribute("x"))||0)+e,o=isDef(t.y.baseVal.value)?t.y.baseVal.value+r:(Number(t.getAttribute("y"))||0)+r;s.push(["x",a],["y",o]);break}case"circle":case"ellipse":{const a=t.cx.baseVal.value+e,o=t.cy.baseVal.value+r;s.push(["cx",a],["cy",o]);break}case"line":{const a=t.x1.baseVal.value+e,o=t.y1.baseVal.value+r,n=t.x2.baseVal.value+e,i=t.y2.baseVal.value+r;s.push(["x1",a],["y1",o],["x2",n],["y2",i]);break}case"polygon":case"polyline":{const a=parsePoints(t.getAttribute("points")).map(t=>(t[0]=Number(t[0])+e,t[1]=Number(t[1])+r,t.join(" "))).join(" ");s.push(["points",a]);break}case"path":{const a=t.getAttribute("d");s.push(["d",movePath({path:a,dx:e,dy:r})]);break}}s.forEach(e=>{t.setAttribute(e[0],e[1])})},applyResize=(t,e)=>{const{scaleX:r,scaleY:s,localCTM:a,bBox:{width:o,height:n}}=e,i=[];switch(t.tagName.toLowerCase()){case"text":case"tspan":{const{x:e,y:l,textLength:c}=t.__data__,{x:h,y:E}=pointTo(a,e,l);i.push(["x",h+(r<0?o:0)],["y",E-(s<0?n:0)],["textLength",Math.abs(r*c)]);break}case"circle":{const{r:e,cx:o,cy:n}=t.__data__,l=e*(Math.abs(r)+Math.abs(s))/2,{x:c,y:h}=pointTo(a,o,n);i.push(["r",l],["cx",c],["cy",h]);break}case"foreignobject":case"image":case"rect":{const{width:e,height:o,x:n,y:l}=t.__data__,{x:c,y:h}=pointTo(a,n,l),E=Math.abs(e*r),d=Math.abs(o*s);i.push(["x",c-(r<0?E:0)],["y",h-(s<0?d:0)],["width",E],["height",d]);break}case"ellipse":{const{rx:e,ry:o,cx:n,cy:l}=t.__data__,{x:c,y:h}=pointTo(a,n,l),E=createSVGMatrix();E.a=r,E.d=s;const{x:d,y:T}=pointTo(E,e,o);i.push(["rx",Math.abs(d)],["ry",Math.abs(T)],["cx",c],["cy",h]);break}case"line":{const{resX1:e,resY1:r,resX2:s,resY2:o}=t.__data__,{x:n,y:l}=pointTo(a,e,r),{x:c,y:h}=pointTo(a,s,o);i.push(["x1",n],["y1",l],["x2",c],["y2",h]);break}case"polygon":case"polyline":{const{points:e}=t.__data__,r=parsePoints(e).map(t=>{const{x:e,y:r}=pointTo(a,Number(t[0]),Number(t[1]));return t[0]=e,t[1]=r,t.join(" ")}).join(" ");i.push(["points",r]);break}case"path":{const{path:e}=t.__data__;i.push(["d",resizePath({path:e,localCTM:a})]);break}}i.forEach(([e,r])=>{t.setAttribute(e,r)})},applyTransformToHandles$1=(t,e,r)=>{const{rotatable:s,rotatorAnchor:a,rotatorOffset:o}=e,{wrapper:n,handles:i,center:l,transform:{wrapperMatrix:c=getTransformToElement(n,n.parentNode)}={}}=t;let{boxMatrix:h,element:E}=r;const{x:d,y:T,width:p,height:u}=E.getBBox(),x=p/2,_=u/2,f=c.inverse().multiply(h),m=pointTo(f,d+x,T+_),y={tl:[d,T],tr:[d+p,T],mr:[d+p,T+_],ml:[d,T+_],tc:[d+x,T],bc:[d+x,T+u],br:[d+p,T+u],bl:[d,T+u],...!l.isShifted&&{center:[d+x,T+_]}},b=Object.entries(y).reduce((t,[e,r])=>(t[e]=pointTo(f,r[0],r[1]),t),{}),M={te:[b.tl,b.tr],be:[b.bl,b.br],le:[b.tl,b.bl],re:[b.tr,b.br]};if(s){const t={};let e=1;switch(a){case"n":t.x=b.tc.x,t.y=b.tc.y;break;case"s":t.x=b.bc.x,t.y=b.bc.y,e=-1;break;case"w":t.x=b.ml.x,t.y=b.ml.y,e=-1;break;case"e":default:t.x=b.mr.x,t.y=b.mr.y}const r="n"===a||"s"===a?Math.atan2(b.bl.y-b.tl.y,b.bl.x-b.tl.x):Math.atan2(b.tl.y-b.tr.y,b.tl.x-b.tr.x),s=o*e,n={x:t.x-s*Math.cos(r),y:t.y-s*Math.sin(r)},{normal:c,radius:h}=i;isDef(c)&&(c.x1.baseVal.value=t.x,c.y1.baseVal.value=t.y,c.x2.baseVal.value=n.x,c.y2.baseVal.value=n.y),isDef(h)&&(h.x1.baseVal.value=m.x,h.y1.baseVal.value=m.y,l.isShifted||(h.x2.baseVal.value=m.x,h.y2.baseVal.value=m.y)),b.rotator=n}Object.keys(M).forEach(t=>{const e=i[t],[r,s]=M[t];isUndef(r)||isUndef(e)||Object.entries({x1:r.x,y1:r.y,x2:s.x,y2:s.y}).map(([t,r])=>e.setAttribute(t,r))}),Object.keys(b).forEach(t=>{const e=i[t],r=b[t];isUndef(r)||isUndef(e)||(e.setAttribute("cx",r.x),e.setAttribute("cy",r.y))})},createHandler$1=(t,e,r,s)=>{const a=createSVGElement("circle",["sjx-svg-hdl",`sjx-svg-hdl-${s}`]),o={cx:t,cy:e,r:4,fill:"#fff",stroke:r,"stroke-width":1,"fill-opacity":1,"vector-effect":"non-scaling-stroke"};return Object.entries(o).forEach(([t,e])=>a.setAttribute(t,e)),a},setLineStyle=(t,e)=>{t.setAttribute("stroke",e),t.setAttribute("stroke-dasharray","3 3"),t.setAttribute("vector-effect","non-scaling-stroke")},storeElementAttributes=t=>{switch(t.tagName.toLowerCase()){case"text":{const e=isDef(t.x.baseVal[0])?t.x.baseVal[0].value:Number(t.getAttribute("x"))||0,r=isDef(t.y.baseVal[0])?t.y.baseVal[0].value:Number(t.getAttribute("y"))||0,s=isDef(t.textLength.baseVal)?t.textLength.baseVal.value:Number(t.getAttribute("textLength"))||null;t.__data__={x:e,y:r,textLength:s};break}case"circle":{const e=t.r.baseVal.value,r=t.cx.baseVal.value,s=t.cy.baseVal.value;t.__data__={r:e,cx:r,cy:s};break}case"foreignobject":case"image":case"rect":{const e=t.width.baseVal.value,r=t.height.baseVal.value,s=t.x.baseVal.value,a=t.y.baseVal.value;t.__data__={width:e,height:r,x:s,y:a};break}case"ellipse":{const e=t.rx.baseVal.value,r=t.ry.baseVal.value,s=t.cx.baseVal.value,a=t.cy.baseVal.value;t.__data__={rx:e,ry:r,cx:s,cy:a};break}case"line":{const e=t.x1.baseVal.value,r=t.y1.baseVal.value,s=t.x2.baseVal.value,a=t.y2.baseVal.value;t.__data__={resX1:e,resY1:r,resX2:s,resY2:a};break}case"polygon":case"polyline":{const e=t.getAttribute("points");t.__data__={points:e};break}case"path":{const e=t.getAttribute("d");t.__data__={path:e};break}}},renderLine$1=([t,e],r,s)=>{const a=createSVGElement("line",["sjx-svg-line",`sjx-svg-line-${s}`]),o={x1:t.x,y1:t.y,x2:e.x,y2:e.y,stroke:r,"stroke-width":1,"vector-effect":"non-scaling-stroke"};return Object.entries(o).forEach(([t,e])=>a.setAttribute(t,e)),a},getBoundingRect$1=(t,e,r=t.getBBox())=>{const{x:s,y:a,width:o,height:n}=r;return[[s,a],[s+o,a],[s+o,a+n],[s,a+n]].map(([t,r])=>{const{x:s,y:a}=pointTo(e,t,r);return[s,a]})};function drag(t,e){if(this.length){const r=isDef(e)&&e instanceof Observable?e:new Observable;return arrReduce.call(this,(e,s)=>(s instanceof SVGElement?checkElement(s)&&e.push(new DraggableSVG(s,t,r)):e.push(new Draggable(s,t,r)),e),[])}}const{EMITTER_EVENTS:EMITTER_EVENTS$2}=EVENT_EMITTER_CONSTANTS,{E_MOUSEDOWN:E_MOUSEDOWN$4,E_TOUCHSTART:E_TOUCHSTART$4}=CLIENT_EVENTS_CONSTANTS;class Cloneable extends SubjectModel{constructor(t,e){super(t),this.enable(e)}_init(){const{el:t,options:e}=this,r=helper(t),{style:s,appendTo:a}=e,o={position:"absolute","z-index":"2147483647",...s};this.storage={css:o,parent:isDef(a)?helper(a)[0]:document.body},r.on(E_MOUSEDOWN$4,this._onMouseDown).on(E_TOUCHSTART$4,this._onTouchStart),EMITTER_EVENTS$2.slice(0,3).forEach(t=>{this.eventDispatcher.registerEvent(t)})}_processOptions(t){let e={},r=null,s=document,a=()=>{},o=()=>{},n=()=>{},i=()=>{};if(isDef(t)){const{style:s,appendTo:l,stack:c,onInit:h,onMove:E,onDrop:d,onDestroy:T}=t;e=isDef(s)&&"object"==typeof s?s:e,r=l||null;const p=isDef(c)?helper(c)[0]:document;a=createMethod(h),o=createMethod(E),n=isFunc(d)?function(t){const{clone:e}=this.storage;objectsCollide(e,p)&&d.call(this,t,this.el,e)}:()=>{},i=createMethod(T)}this.options={style:e,appendTo:r,stack:s},this.proxyMethods={onInit:a,onDrop:n,onMove:o,onDestroy:i}}_start({clientX:t,clientY:e}){const{storage:r,el:s}=this,{parent:a,css:o}=r,{left:n,top:i}=getOffset(a);o.left=`${t-n}px`,o.top=`${e-i}px`;const l=s.cloneNode(!0);helper(l).css(o),r.clientX=t,r.clientY=e,r.cx=t,r.cy=e,r.clone=l,helper(a)[0].appendChild(l),this._draw()}_moving({clientX:t,clientY:e}){const{storage:r}=this;r.clientX=t,r.clientY=e,r.doDraw=!0,r.doMove=!0}_end(t){const{storage:e}=this,{clone:r,frameId:s}=e;e.doDraw=!1,cancelAnimFrame(s),isUndef(r)||(this.proxyMethods.onDrop.call(this,t),r.parentNode.removeChild(r),delete e.clone)}_animate(){const{storage:t}=this;t.frameId=requestAnimFrame(this._animate);const{doDraw:e,clientX:r,clientY:s,cx:a,cy:o}=t;e&&(t.doDraw=!1,this._drag({dx:r-a,dy:s-o}))}_processMove(t,e){const{clone:r}=this.storage,s=`translate(${t}px, ${e}px)`;helper(r).css({transform:s,webkitTranform:s,mozTransform:s,msTransform:s,otransform:s})}_destroy(){const{storage:t,proxyMethods:e,el:r}=this;isUndef(t)||(helper(r).off(E_MOUSEDOWN$4,this._onMouseDown).off(E_TOUCHSTART$4,this._onTouchStart),e.onDestroy.call(this,r),delete this.storage)}disable(){this._destroy()}}function clone(t){if(this.length)return arrMap.call(this,e=>new Cloneable(e,t))}class Subjx extends Helper{drag(){return drag.call(this,...arguments)}clone(){return clone.call(this,...arguments)}}function subjx(t){return new Subjx(t)}Object.defineProperty(subjx,"createObservable",{value:()=>new Observable}),Object.defineProperty(subjx,"Subjx",{value:Subjx}),Object.defineProperty(subjx,"Observable",{value:Observable}),module.exports=subjx;
